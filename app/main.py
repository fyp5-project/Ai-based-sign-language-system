# app/main.py

from fastapi import FastAPI, File, UploadFile
from fastapi.responses import JSONResponse, FileResponse 
from fastapi.staticfiles import StaticFiles
from tensorflow.keras.models import model_from_json
from tensorflow.keras import layers
from tensorflow.keras.applications.resnet50 import preprocess_input as resnet50_preprocess_input_fn
import tensorflow as tf
from contextlib import asynccontextmanager
import os
import json 
import traceback
import numpy as np
from pathlib import Path 

from .core_config import (
    KERAS_MODEL_PATH, STATIC_FILES_DIR, 
    CONVERTED_H264_VIDEOS_DIR, # Serve from here
    COMBINED_VIDEOS_TEMP_DIR
)
from .models import SignToTextResponse, TextToSignRequest, TextToSignResponse
from .services import (
    predict_sign_from_image, 
    translate_english_to_swahili_for_audio,
    generate_swahili_speech,
    initialize_text_to_sign_system, # This will now handle on-startup conversion
    translate_text_to_english_for_video_lookup,
    find_and_combine_sign_videos
)

ml_models = {"keras_sign_model": None} 
model_load_status = {"loaded": False, "error": None, "model_id_at_load": None}

@tf.keras.utils.register_keras_serializable()
class PreprocessInputLayer(layers.Layer):
    def __init__(self, **kwargs): super().__init__(**kwargs)
    def call(self, inputs): return resnet50_preprocess_input_fn(inputs)
    def get_config(self): return super().get_config()

@asynccontextmanager
async def lifespan(app: FastAPI):
    global ml_models, model_load_status
    print("[INFO] FastAPI Lifespan: Application startup sequence initiated.")
    model_load_status["loaded"] = False; model_load_status["error"] = None
    model_load_status["model_id_at_load"] = None; ml_models["keras_sign_model"] = None
    
    print(f"[INFO] Lifespan: STATIC_FILES_DIR is '{STATIC_FILES_DIR}'")
    print(f"[INFO] Lifespan: COMBINED_VIDEOS_TEMP_DIR is '{COMBINED_VIDEOS_TEMP_DIR}'")
    print(f"[INFO] Lifespan: CONVERTED_H264_VIDEOS_DIR is '{CONVERTED_H264_VIDEOS_DIR}'")

    os.makedirs(STATIC_FILES_DIR, exist_ok=True)
    os.makedirs(COMBINED_VIDEOS_TEMP_DIR, exist_ok=True)
    os.makedirs(CONVERTED_H264_VIDEOS_DIR, exist_ok=True) # Ensure converted dir exists

    print("[INFO] Lifespan: Attempting Keras model reconstruction...")
    config_path = os.path.join(KERAS_MODEL_PATH, "config.json")
    weights_path = os.path.join(KERAS_MODEL_PATH, "model.weights.h5") 
    if not os.path.isdir(KERAS_MODEL_PATH) or not os.path.exists(config_path) or not os.path.exists(weights_path):
        model_load_status["error"] = f"Keras model files missing. Dir: {KERAS_MODEL_PATH}"
    else:
        try:
            with open(config_path, 'r') as f: model_json = f.read()
            custom_objects = {'PreprocessInputLayer': PreprocessInputLayer}
            model = model_from_json(model_json, custom_objects=custom_objects)
            model.load_weights(weights_path)
            _ = model.predict(np.zeros((1, 224, 224, 3), dtype=np.float32), verbose=0)
            ml_models["keras_sign_model"] = model
            model_load_status["loaded"] = True
            model_load_status["model_id_at_load"] = id(ml_models["keras_sign_model"])
        except Exception as e:
            model_load_status["error"] = f"Keras model FAILED: {e}"; print(traceback.format_exc())
    if not model_load_status["loaded"]: print(f"[WARNING] Lifespan: Keras Sign-to-Text model NOT LOADED. Error: {model_load_status.get('error', 'Unknown')}")
    else: print(f"[INFO] Lifespan: Keras Sign-to-Text model RECONSTRUCTED. ID: {model_load_status['model_id_at_load']}")

    print("[INFO] Lifespan: Initializing Text-to-Sign system (includes video conversion if needed)...")
    if initialize_text_to_sign_system(): print("[INFO] Lifespan: Text-to-Sign system ready.")
    else: print("[WARNING] Lifespan: Text-to-Sign system init FAILED/PARTIAL.")
        
    print("[INFO] FastAPI Lifespan: Application startup sequence complete.")
    yield 
    
    print("[INFO] FastAPI Lifespan: Shutdown initiated.")
    ml_models.clear(); model_load_status["loaded"] = False
    print("[INFO] Lifespan: Models cleared.")

app = FastAPI(title="Sign Language Translator API", version="1.4.0", lifespan=lifespan) # Incremented version

# Serve general static files (like MP3s from /static/ and combined videos from /static/combined_temp/)
app.mount("/static", StaticFiles(directory=STATIC_FILES_DIR), name="static_general") 

# Serve the CONVERTED H.264 individual sign videos from /videos_converted_h264/
# The URLs generated by services.py for individual clips in combined videos will be like /videos_converted_h264/filename.mp4
# This mount makes them accessible.
app.mount("/videos_converted_h264", StaticFiles(directory=CONVERTED_H264_VIDEOS_DIR), name="static_converted_videos") 


@app.get("/", summary="Root")
async def root(): return {"message": "Sign Language Translator API Active"}

@app.post("/sign-to-text", response_model=SignToTextResponse, summary="Sign Image -> Text, Confidence & Swahili Speech")
async def sign_image_to_text_and_speech(file: UploadFile = File(...)):
    keras_model = ml_models.get("keras_sign_model")
    if keras_model is None:
        return JSONResponse(status_code=503, content={"message": f"Sign model unavailable. Startup: {model_load_status.get('error', 'Unknown')}"})
    try:
        image_bytes = await file.read()
        predicted_english, confidence = predict_sign_from_image(keras_model, image_bytes)
        if predicted_english == "ErrorInPrediction":
             return JSONResponse(status_code=500, content={"message": "Prediction error."})
        translated_swahili = translate_english_to_swahili_for_audio(predicted_english)
        swahili_audio_url = generate_swahili_speech(translated_swahili)
        return SignToTextResponse(
            predicted_english_text=predicted_english,
            prediction_confidence=confidence,
            translated_swahili_text=translated_swahili,
            swahili_audio_url=swahili_audio_url
        )
    except Exception as e:
        print(f"[API ERROR] /sign-to-text: {e}"); print(traceback.format_exc())
        return JSONResponse(status_code=500, content={"message": "Error in sign-to-text."})

@app.post("/text-to-sign", response_model=TextToSignResponse, summary="Text -> Combined Sign Video")
async def text_input_to_sign_video(request: TextToSignRequest):
    try:
        english_lookup = translate_text_to_english_for_video_lookup(request.text, request.source_language)
        # find_and_combine_sign_videos now uses H.264 MP4s as input and tries to output H.264 MP4
        combined_video_url = find_and_combine_sign_videos(english_lookup) 
        message = f"Input: '{request.text}' (Lookup: '{english_lookup}')."
        if combined_video_url: message += " Combined video created."
        else: message += " Could not generate combined video."
        return TextToSignResponse(input_text=request.text, processed_text_for_lookup=english_lookup, combined_video_url=combined_video_url, message=message)
    except Exception as e:
        print(f"[API ERROR] /text-to-sign: {e}"); print(traceback.format_exc())
        return JSONResponse(status_code=500, content={"message": "Error in text-to-sign."})

@app.get("/download-video/{video_filename:path}", summary="Download Combined Video")
async def download_combined_video(video_filename: str):
    # This endpoint serves files from COMBINED_VIDEOS_TEMP_DIR which is inside STATIC_FILES_DIR
    # So the path construction for FileResponse should be relative to that.
    # The video_filename will be like "combined_uuid.mp4" or "combined_uuid.avi"
    file_path = Path(COMBINED_VIDEOS_TEMP_DIR) / video_filename 
    print(f"[API /download-video] Attempting to serve for download: {file_path}")
    if file_path.is_file():
        media_type = 'application/octet-stream' # Force download
        # Determine actual media type for more accuracy if needed, but octet-stream is fine for download
        # if video_filename.lower().endswith(".mp4"):
        #     media_type = "video/mp4"
        # elif video_filename.lower().endswith(".avi"):
        #     media_type = "video/x-msvideo"
        return FileResponse(
            path=file_path, 
            filename=video_filename, 
            media_type=media_type 
        )
    else:
        print(f"[API ERROR] /download-video: File not found: {file_path}")
        return JSONResponse(status_code=404, content={"message": "Video file not found for download."})

